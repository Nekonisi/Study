09\_構造体3.md
---

## 構造体メンバに同じ型へのポインタをもう構造体

- 自己参照的構造体(self-referential structure)

```自己参照的構造体:C

struct data {
	char name[32];
	int age;
	struct data *nextdata;
};

```

### サンプルコード

```selfReferentialStructure:C

#include <stdio.h>
#include <stdlib.h>

typedef struct _tagDATA {
	char name[32];
	int age;
	struct _tagDATA *nextdata;
}DATA;

int main(){
	DATA a = { "小西", 28 },
		b = { "田中", 35 },
		c = { "鈴木", 28 };
	DATA *lpdata;

	a.nextdata = &b;
	b.nextdata = &c;
	c.nextdata = NULL;

	for (lpdata = &a; lpdata; lpdata = lpdata->nextdata){
		printf("%s (%d歳)\n", lpdata->name, lpdata->age);
	}

	system("pause");
	return 0;
}

```

### 出力結果

```output

小西 (28歳)
田中 (35歳)
鈴木 (28歳)
続行するには何かキーを押してください . . .

```

### 解説

```selfReferentialStructure.c:C

	a.nextdata = &b;
	b.nextdata = &c;
	c.nextdata = NULL;

	for (lpdata = &a; lpdata; lpdata = lpdata->nextdata){
		printf("%s (%d歳)\n", lpdata->name, lpdata->age);
	}

```

- for文に注目!
  - 初期化: `DATA`に格納されている最初のアドレス(`&a`)
	- 継続条件: `lpdata`
	  - `NULL`になるまで続く(`&c`まで継続)
	- 再設定式: `lpdata = lpdata->nextdata`
	  - `a.nextdata = b`なので、次のDATA型の要素が指定される。

## 共用体

- 一つの領域を確保して、そこにいろいろなデータ型の
  データを格納できる機能を持つ共用体(union)と呼ばれるデータ型がある。
- 記憶できるのは*一つのメンバだけ*であるので注意！

### 書式

```union:C

union 共用体タグ{
	共用体メンバ;
	...
} 共用体変数;

```

### サンプルコード

```myUnion.c:C

#include <stdio.h>
#include <stdlib.h>

union myUnion{
	int i;
	double d;
	char c;
	char *str;
};

int main(){
	union myUnion u;
	u.i = 200;
	printf("u.i = %d\n", u.i);
	u.d = 95.25;
	printf("u.d = %f\n", u.d);
	u.c = 'A';
	printf("u.c = %c\n", u.c);
	u.str = "ABCDE";
	printf("u.str = %s\n", u.str);

	system("pause");
	return 0;
}

```

### 出力結果

```output

u.i = 200
u.d = 95.250000
u.c = A
u.str = ABCDE
続行するには何かキーを押してください . . .

```
